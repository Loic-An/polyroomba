*******************
# Compte rendu 6
*******************
## Présentation du projet
Ce projet réalisé dans le cadre de notre cours d'arduino en PEIP2 à Polytech Nice-Sophia (prépa intégré) consiste à concevoir un robot aspirateur permettant de cartographier une pièce et de nettoyer ladite pièce de facon autonome. Nous allons pour cela utiliser une carte arduino Uno.

## Séance du 5 février 2024
- je commence par réorganiser la partie code du dépot avec platformIO: travaillant sur vscode, ce plugin est beaucoup plus agréable et simple a utiliser que l'extension arduino. Ensuite j'ai restructuré le code en lui meme: on passe en orienté objet(création de la classe Robot).
- J'ai bien réfléchit et il n'y a pas besoin de pwm pour le ventilateur: étant donné que son débit d'air est deja limite, je n'ai pas besoin de faire varier la vitesse, juste l'allumer ou l'eteindre.
- Pour relier déplacements réels (le robot dans une pièce) et virtuels (ajuster ses coordonnées par rapport au point de départ), il me faut des moteurs équipé d'encodeur: j'ai donc demander à M. Masson et il m'a fournit [ces nouveaux moteurs](https://wiki.dfrobot.com/Micro_DC_Motor_with_Encoder-SJ01_SKU__FIT0450). Ce sont les mêmes caractéristiques que les précédents (120tr/min@6V) mais sur ceux ci sont montés des encodeurs à effet Hall. Il faut donc maintenant ajouter a la liste de chose à faire un pid qui peut controller 2 moteurs. Il existe déja une librairie arduino pour cela, à creuser.
- Je me rend compte que même la solution que j'ai proposé est lourde pour un arduino uno, surtout au niveau de la ram: ne connaissant pas la taille de la pièce et donc le nombre de points, je dois instancier un `std::vector<std::array<short, 2>>` avec l'array representant un couple et donc un point, or un vector a une taille dynamique et peut/va remplir la ram (2KB seulement) rapidement. Je pense donc partir sur un xiao esp32s3 (512KB de ram + 8MB de PSRAM) pour mitiger ce problème de ram. Cette amélioration permet d'avoir un beaucoup plus de puissance de calcul (dual core à 240MHz au lieu d'un coeur à 24MHz), qui va je lespere accelerer aussi la phase de traitement post-acquisition.L'esp a aussi un port microsd ce qui va m'éviter de brancher l'adaptateur, cependant il a un gros probleme: il n'a pas assez de pin. pour palier à ca, je compte quand meme utiliser l'arduino uno mais comme esclave: l'esp et l'arduino communiqueront par un canal I2C que je suis obligé de mettre en place pour le lidar, et l'arduino s'occupera de la gestion des moteurs (roues, brosses, bras balai et ventilo). Je ne sais pas a quel point ceci est une bonne ou mauvaise idée mais au vue du nombre d'interrupts (1 par cran d'encodeur, et il y en a 2) que necessite le pid, il n'est peut etre pas idiot de delester l'esp, ou sinon a voir si un esp de 40pin peut supporter tout cela.
- Nouveau plan pour l'alimentation: batterie ~12V (3x 18650) alimentant l'arduino uno et le ventilo et les moteurs. L'arduino régule du 5V: alimentation du lidar, de l'esp et de la partie commande des cartes moteurs. Les moteurs, supportant 6V (7.5 max) seront alimenté avec un signal pwm avec un duty à 50% et auront a leur bornes un condensateur (non polarisé, céramique, capacitance à determiner) pour lisser et stabiliser la tension à maximum ±6V. 
- Montage de la solution proposé. Les pins de l'esp32 sont en 3.3V et ceux de l'arduino en 5V, pour la communication i2c j'ai opté pour la solution avec un level shifter bi-directionnel 3.3V<->5V pour eviter la solution des resistance pull-up vers le 3.3V qui m'avait l'air hasardeuse. L'esp arrive a recevoir la distance du lidar et a communiquer avec l'arduino (code non publié sur github).
![](/images/20240206_204100.heic)
